/* 
 * Copyright 2015 cornerpirate.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cornerpirate.reportcompiler.Models;

import com.cornerpirate.reportcompiler.Utils.Helper;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *
 * @author cornerpirate
 */
public class Vulnerability implements Comparable {

    protected String identifier;
    protected String import_tool;
    protected String import_tool_id; // where it has such a convenience
    protected String title;
    protected String description;
    protected String recommendation;
    protected String notes;
    protected String portnumber;
    protected String protocol;
    protected String risk_category; // "high", "medium", "low" style
    protected CVSSVector cvss_vector; // object encapsulating CVSSv2 string
    protected String cvss_vector_string; // full cvss v2 vector string
    protected Vector references = new Vector();
    protected Vector affected_hosts = new Vector();
    protected HashMap vulnIdentifiers = new HashMap(); // key=md5(vuln_title),value=import_tool_name
    protected boolean is_custom_risk;
    protected boolean highlighted = false;
    protected boolean is_nessus_compliance_finding = false;
    protected String nessus_compliance_result;
    protected String notes_collection_script;

    public String getNotes_collection_script() {
        return notes_collection_script;
    }

    public void setNotes_collection_script(String notes_collection_script) {
        this.notes_collection_script = notes_collection_script;
    }

    public String getNessus_compliance_result() {
        return nessus_compliance_result;
    }

    public void setNessus_compliance_result(String nessus_compliance_result) {
        this.nessus_compliance_result = nessus_compliance_result;
    }

    public boolean isIs_nessus_compliance_finding() {
        return is_nessus_compliance_finding;
    }

    public void setIs_nessus_compliance_finding(boolean is_nessus_compliance_finding) {
        this.is_nessus_compliance_finding = is_nessus_compliance_finding;
    }

    public boolean containsText(String search_term) {
        String all_text = this.getTitle() + this.getDescription() + this.getRecommendation();
        Pattern r = Pattern.compile(search_term, Pattern.CASE_INSENSITIVE);
        Matcher m = r.matcher(all_text);
        return m.find();
    }

    public boolean isHighlighted() {
        return highlighted;
    }

    public void setHighlighted(boolean highlighted) {
        this.highlighted = highlighted;
    }

    public boolean isIs_custom_risk() {
        return is_custom_risk;
    }

    public void setIs_custom_risk(boolean is_custom_risk) {
        this.is_custom_risk = is_custom_risk;
    }

    public void addAffectedHost(Host host) {
        if (affected_hosts.contains(host) == false) {
            affected_hosts.add(host);
        } else {
            // Host already existed so we should mege the notes
            Host existing = (Host) affected_hosts.get(affected_hosts.indexOf(host));
            Note combined = existing.getNotes();
            combined.setNote_text(combined.getNote_text() + "\n====================\n" + host.getNotes().getNote_text());
            existing.setNotes(combined);
        }
    }

    public void addAffectedHosts(Vector hosts) {
        Enumeration enums = hosts.elements();
        while (enums.hasMoreElements()) {
            Host host = (Host) enums.nextElement();
            this.addAffectedHost(host);
        }
    }

    public Vector getAffectedHosts() {
        return this.affected_hosts;
    }

    public String getImport_tool_id() {
        if (this.import_tool_id == null) {
            return "NULL";
        }
        return import_tool_id;
    }

    public void setImport_tool_id(String import_tool_id) {
        this.import_tool_id = import_tool_id;
    }

    /**
     * We use this to get a number for the risk which is either a fixed score
     * for High, Medium etc or CVSSv2
     *
     * The following shows the score categories. When a category is used then we
     * assign a risk from the middle of the ranges.
     *
     * Critical - 9.0 - 10 - 9.5 High - 7.0 – 8.9 - 8.0 Medium - 4.0 – 6.9 - 6.0
     * Low - 1.0 – 3.9 - 2.0 Info - 0.1 – 0.9 - 0.5 got category Good Practice -
     * 0.0 or N/A
     *
     * @return
     */
    public double getRiskScore() {

        if (this.is_custom_risk) {
            // In this case this vuln should be a custom risk and so return a number
            if (this.getRisk_category().equalsIgnoreCase("critical")) {
                return 9.5;
            } else if (this.getRisk_category().equalsIgnoreCase("high")) {
                return 8.0;
            } else if (this.getRisk_category().equalsIgnoreCase("medium")) {
                return 6.0;
            } else if (this.getRisk_category().equalsIgnoreCase("low")) {
                return 2.0;
            } else if (this.getRisk_category().equalsIgnoreCase("info")) {
                return 0.5;
            } else if (this.getRisk_category().equalsIgnoreCase("none")) {
                return 0.0;
            }

        } else {
            // This is a CVSS risk so do magic to get that risk
            return new CVSSVector(this.getCvss_vector_string()).getRiskScore();
        }

        System.out.println("[CRITICAL PROBLEM]; That Vulnerability had neither a risk category set or a CVSS vector set");
        System.out.println(this.toString());
        return -1;
    }

    /**
     * We use this to get a number for the risk which is either a fixed score
     * for High, Medium etc or CVSSv2
     *
     * The following shows the score categories. When a category is used then we
     * assign a risk from the middle of the ranges. Critical - 9.0 - 10 - 9.5
     * High - 7.0 – 8.9 - 8.0 Medium - 4.0 – 6.9 - 6.0 Low - 1.0 – 3.9 - 2.0
     * Info - 0.1 – 0.9 - 0.5 Good Practice - 0.0 or N/A
     *
     * @return
     */
    public String getRisk_category() {

        if (this.isIs_custom_risk() == false) {
            if (this.getRiskScore() == 0.0) {
                return "None";
            } else if (this.getRiskScore() >= 0.1 && this.getRiskScore() <= 0.9) {
                return "Info";
            } else if (this.getRiskScore() >= 1.0 && this.getRiskScore() <= 3.9) {
                return "Low";
            } else if (this.getRiskScore() >= 4.0 && this.getRiskScore() <= 6.9) {
                return "Medium";
            } else if (this.getRiskScore() >= 7.0 && this.getRiskScore() <= 8.9) {
                return "High";
            } else if (this.getRiskScore() >= 9.0 && this.getRiskScore() <= 10.0) {
                return "Critical";
            }
        }
        // else it has a defined category already
        return this.risk_category;
    }

    public void setRisk_category(String risk_category) {
        this.risk_category = risk_category;
    }

    public CVSSVector getCvss_vector() {
        return this.cvss_vector;
    }

    public String getCvss_vector_string() {
        if (this.is_custom_risk == false) {
            return this.cvss_vector.getCVSSVector();
        } else {
            return "No CVSS Vector";
        }
    }

    public void setCvss_vector_string(String cvss_vector_string) {
        this.cvss_vector = new CVSSVector(cvss_vector_string);
        if (this.cvss_vector == null) {
            this.cvss_vector = new CVSSVector();
        }
    }

    public String getIDsAsString() {
        StringBuilder sb = new StringBuilder();
        HashMap idsMap = this.getIdentifiers();
        Iterator it = idsMap.keySet().iterator();
        while (it.hasNext()) {
            String hash = (String) it.next();
            String tool = (String) idsMap.get(hash);
            sb.append(hash + ":" + tool + "\n");
        }
        //System.out.println(sb.toString());
        return sb.toString();
    }

    public boolean containsIdentifier(HashMap foreign_ids) {

        Iterator it = foreign_ids.keySet().iterator();
        while (it.hasNext()) {
            String this_hash = (String) it.next();
            String this_toolname = (String) foreign_ids.get(this_hash);
            if (containsIdentifier(this_hash, this_toolname)) {
                return true;
            }
        }
        return false;
    }

    public boolean containsIdentifier(String hash, String toolname) {
        //System.out.println("checking hash: " + hash+toolname) ;
        Iterator it = this.vulnIdentifiers.keySet().iterator();
        while (it.hasNext()) {
            String this_hash = (String) it.next();
            String this_toolname = (String) this.vulnIdentifiers.get(this_hash);
            //System.out.println("candidate: " + this_hash + this_toolname) ;

            if ((hash + toolname).equals(this_hash + this_toolname)) {
                //System.out.println("Hash match found");
                return true;
            }
        }

        return false;
    }

    public String getAnIdentifier() {
        // this was not from a tool at any point in its history. It should not have a hash
        if (this.getImport_tool() == null) {
            return this.getTitle(); // this was not from a tool at any point in its history. 
        }
        return identifier;
    }

    /**
     * The identifier should be; <importtool>:<vulnname>
     * It will b MD5 hashed and permanent from the point of importing. This way
     * we can merge multiple scans after modifying the first instance and then
     * marry them up.
     *
     * @param identifier
     *
     * public void setIdentifier(String identifier) { this.identifier = new
     * Helper().MD5(identifier); }
     *
     */
    /**
     * Add an identifier to the hashmap. Most likely done when you are merging a
     * vulnerability.
     *
     * @param tool_name - Nessus, ReportCompiler, that sort of thing
     * @param vuln_title - will be MD5ed and stored in the HashMap
     */
    public void addIdentifier(String tool_name, String vuln_title) {
        if (this.vulnIdentifiers.containsKey(new Helper().MD5(vuln_title)) == false) {
            this.vulnIdentifiers.put(new Helper().MD5(vuln_title), tool_name);
        }
    }

    public void changeReportCompilerID() {
        //System.out.println("==changeReportCompilerID") ;
        if (this.vulnIdentifiers.containsValue("ReportCompiler")) {
            // find the key for the one ReportCompiler issue
            String key = getHashKey("ReportCompiler");

            if (key == null) {
                System.out.println("Somehow this vuln is marked as being a reportcompiler one without the ID map having an entry? Brokened. Should not be possible");
            } else {
                // We have the key. So replace it.
                this.vulnIdentifiers.remove(key);
                this.vulnIdentifiers.put(new Helper().MD5(this.getTitle()), "ReportCompiler");
            }
        }
    }

    public String getHashKey(String it) {

        Iterator itty_bitty_thingy = this.vulnIdentifiers.keySet().iterator();
        while (itty_bitty_thingy.hasNext()) {
            String key = (String) itty_bitty_thingy.next();
            String value = (String) this.vulnIdentifiers.get(key);
            if (value.equals(it)) {
                return key;
            }
        }
        return null;
    }

    /**
     * Add an identifier to the hashmap. Most likely done when you are merging a
     * vulnerability.
     *
     * @param hash - Nessus, ReportCompiler, that sort of thing
     * @param import_tool - will be MD5ed and stored in the HashMap
     */
    public void addIdentifierHash(String hash, String import_tool) {
        if (this.vulnIdentifiers.containsKey(hash) == false) {
            this.vulnIdentifiers.put(hash, import_tool);
        }
    }

    public HashMap getIdentifiers() {
        return this.vulnIdentifiers;
    }

    /**
     * Setup the vuln with its default value.
     */
    public void setIdentifier() {
        this.vulnIdentifiers.put(new Helper().MD5(this.getTitle()), this.getImport_tool());
    }

    public void setIdentifierFromSaveFile(String hash, String import_tool) {
        this.vulnIdentifiers.put(hash, import_tool);
    }

    public String getPortnumber() {
        if (this.portnumber == null) {
            return "NULL";
        }
        return portnumber;
    }

    public void setPortnumber(String portnumber) {
        this.portnumber = portnumber;
    }

    public String getProtocol() {
        if (this.protocol == null) {
            return "NULL";
        }
        return protocol;
    }

    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }

    public String getImport_tool() {
        if (this.import_tool == null) {
            return "NULL";
        }
        return import_tool;
    }

    public void setImport_tool(String import_tool) {
        this.import_tool = import_tool;
    }

    public String getTitle() {
        if (this.title == null) {
            return "NULL";
        }
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        if (this.description == null) {
            return "NULL";
        }
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getRecommendation() {
        if (this.recommendation == null) {
            return "NULL";
        }
        return recommendation;
    }

    public void setRecommendation(String recommendation) {
        this.recommendation = recommendation;
    }

    public String getNotes() {
        if (this.notes == null) {
            return "NULL";
        }
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    /**
     * Add reference to vulnerability if it doesn't already exist
     *
     * @param ref - A Reference Object
     */
    public void addReference(Reference ref) {
        if (this.references.contains(ref) == false) {
            this.references.add(ref);
        }
    }

    public void modifyReference(Reference oldref, Reference newref) {
        if (this.references.contains(oldref) == true) {
            this.references.remove(oldref);
            this.references.add(newref);
        }
    }

    public Vector getReferences() {
        if (this.references == null) {
            return new Vector();
        } else {
            return this.references;
        }
    }

    /**
     * Delete provided reference from list if it exists
     *
     * @param ref - A Reference Object
     */
    public void deleteReference(Reference ref) {
        if (this.references.contains(ref) == true) {
            this.references.remove(ref);
        }
    }

    public Vulnerability mergeVulnerabilities(Vector vulns) {
        Vulnerability merged_vuln = new Vulnerability();
        merged_vuln.setImport_tool("None");
        merged_vuln.setIs_custom_risk(true);
        merged_vuln.setTitle("Merged Vuln");
        merged_vuln.setDescription("This vulnerability was produced by merging the following issues:\n\n");

        double highest_risk = -1;
        String highest_cvss = "";

        Enumeration enums = vulns.elements();
        while (enums.hasMoreElements()) {
            Vulnerability vuln = (Vulnerability) enums.nextElement();
            merged_vuln.setDescription(merged_vuln.getDescription() + vuln.getTitle() + " - " + vuln.getRiskScore() + "\n");
            merged_vuln.addAffectedHosts(vuln.getAffectedHosts());
            // Merge the references
            Enumeration refs = vuln.getReferences().elements();
            while (refs.hasMoreElements()) {
                Reference ref = (Reference) refs.nextElement();
                merged_vuln.addReference(ref);
            }

            // TODO merge identifiers here
            HashMap idsMap = vuln.getIdentifiers();
            Iterator it = idsMap.keySet().iterator();
            while (it.hasNext()) {
                String hash = (String) it.next();
                String tool = (String) idsMap.get(hash);
                merged_vuln.addIdentifierHash(hash, tool);
            }

            if (vuln.getRiskScore() > highest_risk) {
                highest_risk = vuln.getRiskScore();
                highest_cvss = vuln.getCvss_vector_string();
                merged_vuln.setIs_custom_risk(vuln.isIs_custom_risk());
                merged_vuln.setRisk_category(vuln.getRisk_category());
                if (merged_vuln.is_custom_risk == false) {
                    merged_vuln.setCvss_vector_string(highest_cvss);
                }
            }
        }

        return merged_vuln;
    }

    @Override
    public String toString() {
        //return "Vulnerability{" + "title=" + this.getTitle() + ", portnumber=" + this.getPortnumber() + ", protocol=" + this.getProtocol() + ", risk_category=" + this.risk_category + '}';
        String ending = ((this.is_custom_risk == true) ? "CATEGORY" : "CVSS");
        return this.getTitle() + " - " + this.risk_category + " - " + this.getRiskScore() + " - " + ((this.is_custom_risk == true) ? "CATEGORY" : "CVSS");
    }

    @Override
    public int compareTo(Object obj) {
        Vulnerability other = (Vulnerability) obj;
        return Double.compare(this.getRiskScore(), other.getRiskScore());
    }

    public String getAffectedHostsForExcel() {
        String answer = "\"";
        Enumeration enums = this.getAffectedHosts().elements();
        while (enums.hasMoreElements()) {
            Host host = (Host) enums.nextElement();
            answer = answer + host.getHostForExcel() + "\n";
        }
        answer = answer + "\"";
        if (answer.length() >= 32767) {
            System.out.println("== getAffectedHostsForExcel: " + answer.length());
        }
        return answer;
    }

    public void deleteAffectedHost(Host host) {
        this.affected_hosts.remove(host);
    }

    public void modifyAffectedHost(Host previous, Host modified) {
        for (int i = 0; i < this.affected_hosts.size(); i++) {
            Host h = (Host) this.affected_hosts.get(i);
            if (h.getIp_address().equalsIgnoreCase(previous.getIp_address())) {
                h.setHostname(modified.getHostname());
            }
        }
    }

    /**
     * Clone the input vulns risk to the current one. Used by CVSS calculator
     *
     * @param in
     */
    public void cloneRisk(Vulnerability in) {
        if (in.isIs_custom_risk() == true) {
            // Custom Risk
            this.setIs_custom_risk(true);
            this.setRisk_category(in.getRisk_category());
        } else {
            // CVSS Risk
            this.setIs_custom_risk(false);
            this.setCvss_vector_string(in.getCvss_vector_string());
            this.setRisk_category(in.getRisk_category());
        }

    }

    /**
     * Clone the input vulns references to the current one.
     *
     * @param in
     */
    public void cloneReferences(Vulnerability in) {
        this.references = in.getReferences();
    }

    /**
     * Clone the input vulns identifiers to the current one.
     *
     * @param in
     */
    public void cloneIdentifiers(Vulnerability in) {
        this.vulnIdentifiers = in.vulnIdentifiers;
        this.import_tool = in.import_tool;
        this.import_tool_id = in.import_tool_id;
    }

    public void replaceNotes(Host thishost) {
        String this_id = thishost.getIp_address() + thishost.getPortnumber() + thishost.getProtocol();
        Enumeration enums = this.affected_hosts.elements();
        while (enums.hasMoreElements()) {
            Host hst = (Host) enums.nextElement();
            String hst_id = hst.getIp_address() + hst.getPortnumber() + hst.getProtocol();
            if (hst_id.equalsIgnoreCase(this_id)) {
                System.out.println("Replacing notes");
                hst.note = thishost.getNotes();
            }
        }

    }

    ;

    public void deleteAllIds() {
        this.vulnIdentifiers = new HashMap();
    }

    /**
     * This looks for any CVE IDs that exist in the following locations 1) Any
     * reference URLs 2) The title 3) The description. It makes a unique list of
     * them and then returns that as a HashSet
     *
     * @return HashSet - Containing all CVEs within current vulnerability text
     */
    public HashSet getCVEReferences() {
        HashSet cves = new HashSet();

        // Loop through the references looking for CVE's in there
        Enumeration enums = this.getReferences().elements();
        while (enums.hasMoreElements()) {
            Reference ref = (Reference) enums.nextElement();
            if (ref.isCVE()) {
                // This is a cve reference
                String pattern = "CVE-\\d{4}-\\d+";
                // Create a Pattern object
                Pattern r = Pattern.compile(pattern);
                Matcher m = r.matcher(ref.getUrl());
                m.find();
                String cve = m.group();
                cves.add(cve);
            }
        }

        // Look through a text combination of title, and description looking for others
        String grepme = this.getTitle() + "\n" + this.getDescription();
        String pattern = "CVE-\\d{4}-\\d+";
        // Create a Pattern object
        Pattern r = Pattern.compile(pattern);
        Matcher m = r.matcher(grepme);
        while (m.find()) {
            String cve = m.group();
            cves.add(cve);
        }

        return cves;
    }

}
